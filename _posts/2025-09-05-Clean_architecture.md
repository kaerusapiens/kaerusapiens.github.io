---
title: "Kubernetes"
category: "Architecture"
categories: ["Architecture", "Microservices"]
---

# Clean Architecture

Architecture이라는 용어 자체는 꽤 추상적임. 실제적으로 어떻게 사용되고 어떤 형태를 가지는 것이
이상적인가에 대해서 중점

기능중심적인것 뿐만아니라 테스트 가능하며(testable) 유지보수하기 (maintainable) 쉬운 구조,
적응성(adaptable) 있는 구조를 만드는 것에 중점

You’ll learn how to separate core business logic from external concerns, create clear interfaces
between system components, and implement patterns that enable your software to adapt to changing
requirements.

너는 핵심 비즈니스 로직을 외부 관심사로부터 분리하는 방법, 시스템 구성 요소 간의 명확한 인터페이스를
만드는 방법, 그리고 변화하는 요구 사항에 적응할 수 있는 패턴을 구현하는 방법을 배우게 될 것이다.

Good architecture helps you postpone decisions.

'좋은 아키텍처는 결정을 미루는 데 도움이 된다' 단순히 결정을 미루라는 것이 아니라, 나중에 더 많은
정보가 있을 때 더 나은 결정을 내릴 수 있도록 설계하라는 심오한 의미를 담고 있습니다. 불확실성이 높은
상황에서 섣부른 결정을 내리지 않고, 핵심적인 부분에 집중하면서도 확장 가능성을 열어두는 지혜로운
접근 방식을
말합니다. 良いアーキテクチャは、すべての要件が明確になるまで重要な技術的決定を先送りすることができます。

| 한국어                                                | 일본어         | 발음                     |
| ----------------------------------------------------- | -------------- | ------------------------ |
| 유지보수성 (Maintainability)                          | 保守性         | ほしゅせい               |
| 변경 용이성 (Modifiability)                           | 変更容易性     | へんこうよういせい       |
| 결합도 (Coupling)                                     | 結合度         | けつごうど               |
| 응집도 (Cohesion)                                     | 凝集度         | ぎょうしゅうど           |
| 코드 품질 (Code Quality)                              | コード品質     | コードひんしつ           |
| 가독성 (Readability)                                  | 可読性         | かどくせい               |
| 경직성 / 변화에 대한 저항 (Rigidity)                  | 硬直性         | こうちょくせい           |
| 얽힌 의존 관계 (Tangled Dependencies / High Coupling) | 複雑な依存関係 | ふくざつないぞんかんけい |

# Part 1 :Foundations of Clean Architecture in Python

잘 설계된 아키텍처는 코드의 재사용성과 확장성을 높이면서도, 결합도는 낮추고 응집도는 높이는 방향으로
나아가야 합니다. 이를 위해서는 추상화, 캡슐화, 단일 책임 원칙과 같은 객체지향 설계 원칙을 신중하게
적용하는 것이 중요합니다.

주문에 선물 포장 옵션을 추가하는 기능을 구현한다고 가정했을때

- 주문 처리 시스템은 선물 포장 옵션을 지원하도록 확장되어야 합니다.
- 결제 시스템은 선물 포장 비용을 처리할 수 있어야 합니다.
- 알림 시스템은 선물 포장 지침을 포함하는 이메일을 보낼 수 있어야 합니다.
- 재고 시스템은 선물 포장 용품을 추적하기 위해 수정이 필요합니다.
- 가격 엔진은 추가 비용을 계산하기 위해 조정이 필요합니다.
- 사용자 인터페이스(UI)는 선물 포장 옵션을 제시하도록 업데이트해야 합니다.
- 이행 시스템은 선물 포장 지침을 포함하도록 변경이 필요합니다.

## 복잡한 상속 구조 (Tangled Hierarchies)

이 패턴은 코드 재사용을 극대화하기 위해 클래스들이 과도하게 깊고 복잡한 상속 관계를 맺을 때
발생합니다. 마치 엉켜버린 실타래처럼, 클래스 간의 관계가 너무 복잡해져서 의도하지 않은 부작용을
일으키기 쉽습니다.

### 문제점

- 취약한 시스템 (Fragile System): 상속 관계의 최상위에 있는 부모 클래스에 작은 변경이라도 가해지면,
  상속을 받은 모든 하위 클래스에 예기치 않은 부작용이 발생할 수 있습니다. 이는 시스템 전체의
  안정성을 크게 해칩니다.

- 높은 결합도 (High Coupling): 부모와 자식 클래스 간의 관계가 매우 밀접해져서, 특정 클래스를
  독립적으로 이해하거나 테스트하기 어렵습니다. 이는 코드의 재사용성을 오히려 떨어뜨리고, 리팩토링을
  어렵게 만듭니다.

- 낮은 가독성 (Poor Readability): 개발자가 특정 클래스의 동작을 이해하려면 상속 계층 구조를 따라
  여러 부모 클래스를 거슬러 올라가야 합니다. 이 과정은 시간 소모적이며 코드 이해를 방해합니다.

## 거대하고 추상화가 부족한 클래스 (Monolithic Classes)

이 패턴은 하나의 클래스가 너무 많은 책임을 떠맡아 '만능 클래스(Do-everything Class)'가 될 때
나타납니다. 객체지향의 핵심 원칙인 **단일 책임 원칙(Single Responsibility Principle)**을 위반하며,
응집도가 낮고 결합도가 높은 결과를 초래합니다.

### 문제점

- 낮은 유지보수성 (Low Maintainability): 한 클래스에 너무 많은 기능이 집중되어 있기 때문에, 버그를
  수정하거나 새로운 기능을 추가하기가 매우 어렵습니다. 하나의 기능을 변경하려다 다른 기능에 영향을
  미치는 부작용이 흔하게 발생합니다.

- 높은 코드 중복 (High Code Duplication): 특정 기능을 필요로 하는 여러 곳에서 거대 클래스의 일부
  코드를 복사해서 사용하는 경우가 많아집니다. 이는 코드를 비효율적으로 만들고, 기능의 일관성을
  유지하기 어렵게 합니다.

-테스트의 어려움 (Difficulty in Testing): 클래스가 너무 많은 기능을 포함하고 있어 단위 테스트를
작성하기가 복잡하고, 테스트 자체의 신뢰성도 떨어집니다. 특정 기능만 테스트하기 위해 불필요한 다른
기능들을 모두 준비해야 하기 때문입니다.

## オブジェクト指向の原則

結合度を低く保ち、凝集度を高くするためには、以下の原則を適用します。

- 抽象化（Abstraction）: 複雑な詳細を隠し、高レベルのインターフェースのみを公開する技術です。これにより、開発者は詳細を気にすることなく、インターフェースを通じてモジュールを操作できます。これにより、システムの理解が容易になり、実装の変更がインターフェースに影響を与えにくくなります。※継承を使い過ぎると、親クラスの依存関係が子クラスに伝播し、結合度が高くなる可能性があります。継承は慎重に使用し、必要な場合にのみ利用することが重要です。

- カプセル化（Encapsulation）: データと、それを操作するメソッドを一つのオブジェクトにまとめることです。これにより、外部からオブジェクトの内部状態が直接変更されるのを防ぎ、データの整合性を保ちます。これは結合度を下げるのに役立ちます。

- 単一責任の原則（Single Responsibility Principle,
  SRP）: クラスはたった一つの責任を持つべきであるという原則です。この原則に従うことで、一つのクラスに複数の機能が詰め込まれるのを防ぎ、凝集度を高めます。もしクラスの機能が多すぎると、変更時に予期せぬ副作用が発生しやすくなります。
